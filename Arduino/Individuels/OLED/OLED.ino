#include "U8glib.h"

#define CLK 2 // Broche 2 en tant que CLK, raccordé sur CLK du KY-040
#define DT 4 // Broche 4 en tant que DT, raccordé sur DT du KY-040
#define SW 5 // Broche 5 en tant que SW, raccordé sur SW du KY-040

// Initilisation de l'écran
U8GLIB_SSD1306_128X64 u8g(U8G_I2C_OPT_DEV_0 | U8G_I2C_OPT_NO_ACK | U8G_I2C_OPT_FAST);

// Icône paramètre
const unsigned char bitmap_icone_param [] PROGMEM = {
  0x00, 0x00, 0x01, 0x80, 0x03, 0xc0, 0x16, 0x68, 0x3c, 0x3c, 0x21, 0x84, 0x33, 0xcc, 0x16, 0x68, 
	0x16, 0x68, 0x33, 0xcc, 0x21, 0x84, 0x3c, 0x3c, 0x16, 0x68, 0x03, 0xc0, 0x01, 0x80, 0x00, 0x00
};

// Icône graphique
const unsigned char bitmap_icone_graph [] PROGMEM = {
  0x00, 0x00, 0x80, 0x00, 0x84, 0x00, 0xa4, 0x00, 0x82, 0x00, 0xc2, 0x00, 0xc1, 0x00, 0x81, 0x00, 
	0x80, 0x00, 0x80, 0x82, 0x80, 0x82, 0x80, 0x00, 0x80, 0x44, 0x80, 0x28, 0x80, 0x00, 0x00, 0x00
};

// Icône reset
const unsigned char bitmap_icone_reset [] PROGMEM = {
  0x00, 0xc0, 0x00, 0xf0, 0xf0, 0x18, 0x30, 0x04, 0x70, 0x06, 0x50, 0x02, 0xc0, 0x03, 0xc0, 0x03, 
	0xc0, 0x03, 0xc0, 0x03, 0x40, 0x02, 0x60, 0x06, 0x20, 0x04, 0x18, 0x18, 0x0f, 0xf0, 0x03, 0xc0
};

// Tableau des bitmaps
const unsigned char* bitmap_icones[3] = {
  bitmap_icone_param,
  bitmap_icone_graph,
  bitmap_icone_reset
};

// Barre de défilement
const unsigned char bitmap_barre [] PROGMEM = {
  0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 
  0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 
  0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 
  0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x02, 0x00, 0x00
};

// Entourer l'élément sélectionné
const unsigned char bitmap_item_actuel [] PROGMEM = {
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0, 
  0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x20, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x40, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 
  0x3f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xe0, 
  0x1f, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xc0
};

// Gain
int gain = 300;

// Variables pour le menu
const int nbr_items = 3; // Nombre d'items dans le menu principal
const int taille_max_items = 20; // Taille maximale des items
int item_actuel = 0; // Item du menu séléctionné
int ecran_actuel = 0; // 0 = Menu, 1 = Amplification, 2 = Valeurs

// Array qui contient les noms des menus
char items_menu [nbr_items] [taille_max_items] = {
  {"Amplification"}, 
  {"Valeurs"},
  {"Reset"}
 };

// Variables pour le KY-040
volatile unsigned int Pos_encodeur = 0; // Variable de l'encodeur
unsigned int ancienne_pos = 0; // Variable utilisée pour checker un changement de position de l'encodeur
// Variables pour le debounce du bouton
int etatBouton = HIGH;             // L'état actuel du bouton (HIGH = non pressé, LOW = pressé)
int dernierEtatBouton = HIGH;      // Le dernier état stable du bouton
unsigned long dernierTempsDebounce = 0;  // Le dernier temps où le bouton a changé d'état
unsigned long intervalleDebounce = 50;   // L'intervalle de debounce en millisecondes


void setup() {
  pinMode(CLK, INPUT_PULLUP);
  pinMode(DT, INPUT_PULLUP);
  pinMode(SW, INPUT_PULLUP);
  // Configuration de l'interruption pour l'encodeur
  attachInterrupt(digitalPinToInterrupt(CLK), Encodeur_interrupt, RISING);
  u8g.setColorIndex(1);  // Défini les écritures en blanc
}


void loop() {
  noInterrupts(); // Désactive les interruptions pour une lecture atomique
  unsigned int posActuelle = Pos_encodeur; // Copie atomique de Pos_encodeur
  interrupts(); // Réactive les interruptions

  // Logique de navigation dans le menu avec l'encodeur
  if (ecran_actuel == 0) { // La navigation dans le menu est active seulement si ecran_actuel == 0
    if (posActuelle != ancienne_pos) { // Si l'on détecte un changement
      if (posActuelle > ancienne_pos) { // Rotation vers le haut
        item_actuel--;
        if (item_actuel < 0) {
          item_actuel = nbr_items - 1; // Boucle au dernier élément si on dépasse le premier
        }
      } else { // Rotation vers le bas
        item_actuel++;
        if (item_actuel >= nbr_items) {
          item_actuel = 0; // Boucle au premier élément si on dépasse le dernier
        }
      }
      ancienne_pos = posActuelle; // Mise à jour de l'ancienne position
    }
  }

  int lectureBouton = digitalRead(SW); // On lit l'état du bouton
  if (lectureBouton != dernierEtatBouton) { // S'il est différent
    dernierTempsDebounce = millis(); // On timestamp le moment où il est appuyé
  }
  if ((millis() - dernierTempsDebounce) > intervalleDebounce) { // S'il est appuyé pendant un certain nombre de millisecondes
    if (lectureBouton != etatBouton) { // Si l'état du bouton a changé
      etatBouton = lectureBouton; // On modifie l'état
      if (etatBouton == LOW) { // Si le bouton est effectivement pressé
        if (ecran_actuel == 0) { // Si on est sur le menu
          if (item_actuel == 2) { //Si on est sur le bouton reset
            asm volatile ("  jmp 0"); // Reset de la carte
          } else {
            ecran_actuel = item_actuel + 1; // On va dans l'écran de l'item séléctionné
          }
        } else { // On revient au menu principal
          ecran_actuel = 0;
        }
      }
    }
  }
  dernierEtatBouton = lectureBouton; // On met à jour l'ancien état

  menu_page(item_actuel, gain); // On écrit sur le menu
}

void menu_page(int item_actuel, int gain){

  u8g.firstPage(); // Nécessaire
  do {
    // Ecran menu
    if (ecran_actuel == 0) {
      // Tour d'item sélectionné
      u8g.drawBitmapP(0, 64/nbr_items * item_actuel + item_actuel, 128/8, 21, bitmap_item_actuel);

      // Police
      u8g.setFont(u8g_font_7x14);

      // Amplification
      u8g.drawStr(25, 15, items_menu[0]); 
      u8g.drawBitmapP( 4, 2, 16/8, 16, bitmap_icones[0]);          

      // Valeurs
      u8g.drawStr(25, 15+20+2, items_menu[1]);   
      u8g.drawBitmapP( 4, 24, 16/8, 16, bitmap_icones[1]);     

      // Reset    
      u8g.drawStr(25, 15+20+20+2+2, items_menu[2]);   
      u8g.drawBitmapP( 4, 46, 16/8, 16, bitmap_icones[2]);  

      // Barre de défilement
      u8g.drawBitmapP(128-8, 0, 8/8, 64, bitmap_barre);

      // Emplacement de la barre de défilement
      u8g.drawBox(125, 64/nbr_items * item_actuel, 3, 64/nbr_items);           
    }

    // Ecran amplification
    if (ecran_actuel == 1) {
      // Tour d'item sélectionné
      u8g.drawBitmapP(0, 44, 128/8, 21, bitmap_item_actuel);

      // Police
      u8g.setFont(u8g_font_7x14);

      // Amplification
      u8g.drawStr(25, 15, items_menu[0]); 
      u8g.drawBitmapP(2, 2, 16/8, 16, bitmap_icones[0]);

      // Gain
      u8g.drawStr(4, 37, ("Gain : " + String(gain)).c_str()); 

      // Retour
      u8g.drawStr(25, 59, "Retour");   
      u8g.drawBitmapP(4, 46, 16/8, 16, bitmap_icones[2]);
    }

    // Ecran valeurs
    if (ecran_actuel == 2) {
      // Tour d'item sélectionné
      u8g.drawBitmapP(0, 44, 128/8, 21, bitmap_item_actuel);

      // Police
      u8g.setFont(u8g_font_7x14);

      // Flex
      u8g.drawStr(4, 15, ("Flex : " + String(gain) + " Omhs").c_str()); 
      // Capt
      u8g.drawStr(4, 37, ("Capt : " + String(gain) + " Omhs").c_str());

      // Retour
      u8g.drawStr(25, 59, "Retour");   
      u8g.drawBitmapP(4, 46, 16/8, 16, bitmap_icones[2]);
    }
  } while (u8g.nextPage()); // Nécessaire
}

// Fonction d'interrupt qui modifie l'état la variable de position lorsqu'il change
void Encodeur_interrupt() {
  if (digitalRead(DT)==HIGH) { // Si l'on tourne à droite
    Pos_encodeur++;
  } else { // Si l'on tourne à gauche
    Pos_encodeur--;
  }
}